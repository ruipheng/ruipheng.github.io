<!DOCTYPE html ><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>JSF页面间参数传递总结</title></head><body><img src="http://m1.img.srcdd.com/farm2/172/5DBF139516741BF9B4353638F7A5C6AC_1_1.GIF" /><span> </span><img src="http://m1.img.srcdd.com/farm2/172/5DBF139516741BF9B4353638F7A5C6AC_1_1.GIF" /><br /><span>一、从JSF页面传递参数给托管Bean</span><br />&nbsp;虽然利用h:commandLink 和h:commandButton组件，可以通过action和actionListener来触发托管Bean中的方法，但是不能向这些方法中传递参 数。对于动态传递参数，不是不可以实现，这点可以通过使用f:attribute来实现。而且f:attribute也可以很好的和 actionListener联合使用。<br />&nbsp;例子：<br />&lt;h:commandLink actionListener=&quot;#{myBean.action}&quot;&gt;<br />&nbsp;&lt;f:attribute name=&quot;attrname1&quot; value=&quot;attrvalue1&quot; /&gt;<br />&nbsp;&lt;f:attribute name=&quot;attrname2&quot; value=&quot;attrvalue2&quot; /&gt;<br />&nbsp;...&nbsp;<br />&nbsp;&lt;h:outputText value=&quot;Click here&quot; /&gt;<br />&lt;/h:commandLink&gt;<br />&nbsp;<br />&lt;h:commandButton value=&quot;Press here&quot; actionListener=&quot;#{myBean.action}&quot;&gt;<br />&nbsp;&lt;f:attribute name=&quot;attrname1&quot; value=&quot;attrvalue1&quot; /&gt;<br />&nbsp;&lt;f:attribute name=&quot;attrname2&quot; value=&quot;attrvalue2&quot; /&gt;<br />&nbsp;...<br />&lt;/h:commandButton&gt;<br /><br />&nbsp;这些属性可以通过父组件的getAttributes()方法取到，父组件可以通过传递给actionListener的ActionEvent实例取到<br /><br /><br />public void action(ActionEvent event)<br />&nbsp;...{&nbsp;<br />&nbsp;String attrvalue1 = (String) event.getComponent().getAttributes().get(&quot;attrname1&quot;);<br />&nbsp;String attrvalue2 = (String) event.getComponent().getAttributes().get(&quot;attrname2&quot;);<br />&nbsp;...<br />&nbsp;}<br /><br />变量attrvalue1和attrvalue2包含从f:attribute set进来的值。<br />另一个欠文雅的方式就是通过f:param组件来传值，这个只是对h:commandLink起效。<br /><br /><br />&lt;h:commandLink action=&quot;#{myBean.action}&quot;&gt;<br />&nbsp;&lt;f:param name=&quot;paramname1&quot; value=&quot;paramvalue1&quot; /&gt;<br />&nbsp;&lt;f:param name=&quot;paramname2&quot; value=&quot;paramvalue2&quot; /&gt;<br />&nbsp;...<br />&nbsp;&lt;h:outputText value=&quot;Click here&quot; /&gt;<br />&lt;/h:commandLink&gt;<br /><br />&nbsp;这些参数可以通过FacesContext的getRequestParameterMap()方法取到。通过下面的方法，可以用f:param的name来获取任何写在command块中f:param的值。<br /><br />public static String getFacesParamValue(String name)<br />&nbsp;...{&nbsp;<br />&nbsp;return (String) FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap().get(name);<br />&nbsp;}<br /><br />上面的方法可以用在任何Bean的方法中。举例<br /><br /><br />public void action()<br />&nbsp;...{&nbsp;<br />&nbsp;String paramvalue1 = getFacesParamValue(&quot;paramname1&quot;);&nbsp;<br />&nbsp;String paramvalue2 = getFacesParamValue(&quot;paramname2&quot;);&nbsp;<br />&nbsp;...<br />&nbsp;}<br /><br />变量paramvalue1和paramvalue2包含从f:param set进来的值。<br />不过要注意，属性的名字要唯一，而且不能用其他组件的属性名，比如：&quot;id&quot;, &quot;name&quot;, &quot;value&quot;,&quot;binding&quot;, &quot;rendered&quot;,等。<br /><br /><span>二、从JSF页面传递组件属性到托管Bean</span><br />&nbsp;f:attribute 组件也可以用来访问，任何绑定在托管Bean的UI组件的属性。这些属性值可以通过父组件的getAttributes()来获得。因为不能以方法参数的 方式传值给托管Bean绑定的UI组件的getter和setter方法，这时f:attribute就会非常有用。这里有个UI组件绑定到托管Bean 的基础例子<br /><br />&lt;h:outputText binding=&quot;#{myBean.myText}&quot; value=&quot;#{myBean.myTextValue}&quot;&gt;<br />&nbsp;&lt;f:attribute name=&quot;attributename&quot; value=&quot;attributevalue&quot; /&gt;<br />&nbsp;&lt;/h:outputText&gt;<br /><br /><br /><br /><br />托管Bean代码：<br /><br />import javax.faces.component.html.HtmlOutputText;<br />public class MyBean<br />...{&nbsp;<br />&nbsp;private HtmlOutputText myText;<br />&nbsp;<br />&nbsp;public HtmlOutputText getMyText()<br />&nbsp;...{&nbsp;<br />&nbsp;return myText;&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;public String getMyTextValue()<br />&nbsp;...{&nbsp;<br />&nbsp;return (String) myText.getAttributes().get(&quot;attributename&quot;);&nbsp;<br />&nbsp;}<br />&nbsp;<br />&nbsp;public void setMyText(HtmlOutputText myText)<br />&nbsp;...{&nbsp;<br />&nbsp;this.myText = myText;<br />&nbsp;}<br />}<br /><br /><span>三、在请求之间传递对象（Passing objects from request to request）</span><br />&nbsp;如果有一个request范围内的托管Bean，在下一个请求中想要重用这个bean的属性，参数，或者对象，但是不想一遍又一遍的初始化这个Bean。可以用h:inputhidden来解决这个问题。这里有个简单的例子：<br /><br />&lt;h:form&gt;&nbsp;<br />&nbsp;...<br />&nbsp;&lt;h:inputHidden value=&quot;#{myBean.value}&quot; /&gt;<br />&nbsp;...<br />&lt;/h:form&gt;<br /><br />另一种方法就是用SessionMap来保存那些需要保存在session中的值。<br /><br />public class MyBean<br />...{&nbsp;<br />&nbsp;public Object getMyValue()<br />&nbsp;...{&nbsp;<br />&nbsp;return FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(&quot;MyBeanMyValue&quot;);<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;public void setMyValue(Object myValue)<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(&quot;MyBeanMyValue&quot;, myValue);<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// This might be useful.&nbsp;<br />&nbsp;private void resetSessionValue(Object myKey)<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext.getCurrentInstance().getExternalContext().getSessionMap().remove(myKey);<br />&nbsp;}<br />}<br /><br /><span>四、在托管Bean之间通信</span><br />&nbsp;实践时会有多个托管Bean。如果设计需要，可以利用getSessionMap()在托管Bean之间通信。一个例子，有两个托管Bean：(<span>此法可借鉴</span>)<br /><br />&lt;managed-bean&gt;<br />&nbsp;&lt;managed-bean-name&gt;myBean1&lt;/managed-bean-name&gt;<br />&nbsp;&lt;managed-bean-class&gt;mypackage.MyBean1&lt;/managed-bean-class&gt;<br />&nbsp;&lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;<br />&nbsp;&lt;/managed-bean&gt;<br />&nbsp;&lt;managed-bean&gt;<br />&nbsp;&lt;managed-bean-name&gt;myBean2&lt;/managed-bean-name&gt;<br />&nbsp;&lt;managed-bean-class&gt;mypackage.MyBean2&lt;/managed-bean-class&gt;<br />&nbsp;&lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;<br />&lt;/managed-bean&gt;<br /><br />&nbsp;托管Bean myBean1和myBean2是支撑Bean MyBean1.java和MyBean2.java的实例，它们可以通过JSF页面来访问。不管它们的managed-bean-scope是 request还是session。如果managed-bean-scope被设置成session，在整个session范围内可以使用同一个 Bean的实例；如果managed-bean-scope被设置成request，那么每个request（form action）每次会创建一个Bean的实例。<br /><br />&nbsp;用下面的方法，可以为每个托管Bean set和get static的参数。可以把它写成protected方法，放在一个超类中，让每个托管Bean继承，这会非常有用，或者写入一个Util类中，自己选择。<br /><br />public class MySuperBean<br />...{&nbsp;<br />&nbsp;protected static Object getSessionValue(Object myKey)<br />&nbsp;...{&nbsp;<br />&nbsp;return FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(myKey);<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;protected static void setSessionValue(Object myKey, Object myValue)<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(myKey, myValue);<br />&nbsp;}<br />}<br /><br />public class MyBean1 extends MySuperBean<br />...{&nbsp;<br />&nbsp;public void myMethod()<br />&nbsp;...{&nbsp;<br />&nbsp;String myValue = &quot;value1&quot;;&nbsp;<br />&nbsp;setSessionValue(&quot;MyBean1MyValue&quot;, myValue);<br />&nbsp;...&nbsp;<br />&nbsp;}<br />}<br />public class MyBean2 extends MySuperBean<br />...{&nbsp;<br />&nbsp;public void myMethod()<br />&nbsp;...{&nbsp;<br />&nbsp;String myValue = (String) getSessionValue(&quot;MyBean1MyValue&quot;);<br />&nbsp;...&nbsp;<br />&nbsp;}<br />}<br /><br /><span>五、<span>在托管Bean中访问另一个托管Bean</span></span><br />&nbsp;如果有很多托管Bean，想要从其中一个托管Bean访问其他的托管Bean，这里有六中方法。<br />&nbsp;可以使用：<br />&nbsp;1）getVariableResolver<br />&nbsp;2）createValueBinding<br />&nbsp;3）getELResolver (since JSF 1.2)<br />&nbsp;4）createValueexpression_r(since JSF 1.2)<br />&nbsp;5）getRequestMap<br />&nbsp;6）getSessionMap.<br /><br />举例：假设有两个托管Bean<br />&lt;managed-bean&gt;<br />&nbsp;&lt;managed-bean-name&gt;myBean1&lt;/managed-bean-name&gt;<br />&nbsp;&lt;managed-bean-class&gt;mypackage.MyBean1&lt;/managed-bean-class&gt;<br />&nbsp;&lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;<br />&lt;/managed-bean&gt;<br />&lt;managed-bean&gt;<br />&lt;managed-bean-name&gt;myBean2&lt;/managed-bean-name&gt;<br />&nbsp;&lt;managed-bean-class&gt;mypackage.MyBean2&lt;/managed-bean-class&gt;<br />&nbsp;&lt;managed-bean-scope&gt;session&lt;/managed-bean-scope&gt;<br />&lt;/managed-bean&gt;<br /><br />&nbsp;托管Bean myBean1和myBean2是支撑Bean MyBean1.java和MyBean2.java的实例，它们可以通过JSF页面来访问。不管它们的managed-bean-scope是request还是session。<br />&nbsp;只是要注意的是，getRequestMap在托管Bean被设置成request的时候使用，getSessionMap在托管Bean被设置成session的时候使用。<br /><br />&lt;h:form&gt;&nbsp;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action1}&quot; value=&quot;action1&quot; /&gt;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action2}&quot; value=&quot;action2&quot; /&gt;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action3}&quot; value=&quot;action3&quot; /&gt;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action4}&quot; value=&quot;action4&quot; /&gt;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action5}&quot; value=&quot;action5&quot; /&gt;<br />&nbsp;&lt;h:commandButton action=&quot;#{myBean1.action6}&quot; value=&quot;action6&quot; /&gt;<br />&nbsp;&lt;h:outputText binding=&quot;#{myBean2.text}&quot; /&gt;<br />&lt;/h:form&gt;<br /><br />MyBean1.java:<br /><br />package mypackage;<br />import javax.faces.context.FacesContext;<br />public class MyBean1<br />...{&nbsp;<br />&nbsp;// Using VariableResolver. NOTE: this is deprecated since JSF 1.2!&nbsp;<br />&nbsp;public void action1()<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext context = FacesContext.getCurrentInstance();&nbsp;<br />&nbsp;MyBean2 myBean2 = (MyBean2) context.getApplication().getVariableResolver().resolveVariable(context, &quot;myBean2&quot;);<br />&nbsp;myBean2.getText().setValue(&quot;action1&quot;);&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// Using ValueBinding. NOTE: this is deprecated since JSF 1.2!&nbsp;<br />&nbsp;public void action2()<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext context = FacesContext.getCurrentInstance();<br />&nbsp;MyBean2 myBean2 = (MyBean2) context.getApplication().createValueBinding(&quot;#{myBean2}&quot;).getValue(context);&nbsp;<br />&nbsp;myBean2.getText().setValue(&quot;action2&quot;);&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// Using ELResolver. NOTE: this is implemented since JSF 1.2!&nbsp;<br />&nbsp;public void action3()<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext context = FacesContext.getCurrentInstance();<br />&nbsp;MyBean2 myBean2 = (MyBean2) context.getELContext().getELResolver().getValue(context.getELContext(), null, &quot;myBean2&quot;);<br />&nbsp;myBean2.getText().setValue(&quot;action3&quot;);<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// Using ValueExpression. NOTE: this is implemented since JSF 1.2!&nbsp;<br />&nbsp;public void action4()<br />&nbsp;...{&nbsp;<br />&nbsp;FacesContext context = FacesContext.getCurrentInstance();<br />&nbsp;MyBean2 myBean2 = (MyBean2) context.getApplication().getExpressionFactory().createValueexpression_r(context.getELContext(), &quot;#{myBean2}&quot;, MyBean2.class).getValue(context.getELContext());<br />&nbsp;myBean2.getText().setValue(&quot;action4&quot;);&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// Using RequestMap. NOTE: myBean2 should be request scoped!&nbsp;<br />&nbsp;public void action5()<br />&nbsp;...{&nbsp;<br />&nbsp;Object object = FacesContext.getCurrentInstance().getExternalContext().getRequestMap().get(&quot;myBean2&quot;);<br />&nbsp;// This only works if myBean2 is request scoped.&nbsp;<br />&nbsp;if (object != null)<br />&nbsp;...{&nbsp;<br />&nbsp;MyBean2 myBean2 = (MyBean2) object;<br />&nbsp;myBean2.getText().setValue(&quot;action5&quot;);&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;// Using SessionMap. NOTE: myBean2 should be session scoped!&nbsp;<br />&nbsp;public void action6()<br />&nbsp;...{&nbsp;<br />&nbsp;Object object =&nbsp;FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(&quot;myBean2&quot;);<br />&nbsp;// This only works if myBean2 is session scoped.&nbsp;<br />&nbsp;if (object != null)<br />&nbsp;...{&nbsp;<br />&nbsp;MyBean2 myBean2 = (MyBean2) object;<br />&nbsp;myBean2.getText().setValue(&quot;action6&quot;);<br />&nbsp;}&nbsp;<br />&nbsp;}<br /><br />}<br /><br />MyBean2.java:<br /><br />package mypackage;<br />import javax.faces.component.html.HtmlOutputText;<br />public class MyBean2<br />...{&nbsp;<br />&nbsp;private HtmlOutputText text;&nbsp;<br />&nbsp;<br />&nbsp;public HtmlOutputText getText()<br />&nbsp;...{&nbsp;<br />&nbsp;return text;&nbsp;<br />&nbsp;}&nbsp;<br />&nbsp;<br />&nbsp;public void setText(HtmlOutputText text)<br />&nbsp;...{&nbsp;<br />&nbsp;this.text = text;&nbsp;<br />&nbsp;}<br />}<br /><br />-----------------------------------------------------------------------------------<br /><br />jsf页面参数的传递及加载数据(又一篇)<br /><br /><p>在同一个页面实现功能，可以用ActionListener或用Action过程指向自身。</p><p>在不同的页面之间导航，可以用Action或Action过程，用ActionListener来处理传递的参数，加载数据。</p><p>&nbsp;</p><p>一般的流程是：向一个页面传递参数，并依参数对这个页面的数据进行初始化，加载数据，然后再在视图jsp中显示数据。当然，简单的页面不需要接受参数，甚至不用加载数据。</p><p>&nbsp;</p><p>由一个页面向另一个页面传递参数方法：</p><p>a.在facesconfig.xml的配置文件中，向该页面的ManageredBean的ManageredProperty注入request的参数＃{param.name}</p><p>&nbsp;</p><p>b.先获取该页面的ManageredBean，在代码中向它设值。</p><p>//获取BackingBean</p><p>Object BackingBean=&nbsp;FacesContext.getCurrentInstance().getApplication().getVariableResolver().resolveVariable(context, &quot;BeanName&quot;);</p><p>&nbsp;</p><p>c.向request中设值，再在该页面的ManageredBean中读取。</p><p>//设request值</p><p>FacesContext.getCurrentInstance().getExternalContext.getRequestMap().put(&quot;someKey&quot;, &quot;someValue&quot;);&nbsp;</p><p>//读request值</p><p>Map&nbsp;params = FacesContext.getCurrentInstance().getExternalContext().getRequestParameterMap();</p><p>String someValue = params.get(&quot; id &quot;);</p><p>&nbsp;</p><p>d.设置ActionListener（一般用于处理页面部件的事件。）</p><p>&nbsp;</p><p>e.设置Session(Application)或用作用范围为Session(Application)的ManagerdBean.（该两类Bean存活范围长，占用服务器资源，开销较大，不能大量使用。一般不用于向另一个页面传递参数。）</p><p>&nbsp;&nbsp;<br /></p><p>JSF页面初始化数据的方法（实际上是初始化它的BackingBean，让它依据不同的条件（参数）装载数据）：&nbsp;&nbsp;</p><p>1.在BackingBean的无参数的构造函数中初始化（如读取向它传递的Request等值、读取数据库或文件中持久的数据）</p><p>缺点：必须放弃ManageredProperty的注入，用Request来传递参数。因为构造函数先执行，然后再来注入属性值。</p><p>优点是：简单，易用，不易出错。且可以直接用标准Url方式调用，如/ok.jsf?name=john，与其它的java web程序好兼容。</p><p>&nbsp;</p><p>2.利用ManageredBean的ManagerdProperty的值注入。包括注入Request参数 如#{parap.name}.在get或Set某一属性时，依据传递的参数来初始化数据。</p><p>（在set某个属性时初始化，容易产生有些属性还没有被注入初始化，而在get某个属性时初始化数据，又有可能该属性未被调用，则无法完成初始化工作了。）</p><p>&nbsp;</p><p>3.在代码Action中转向前获取该页面的BackingBean,来初始化它。</p><p>缺点是：依赖于代码Action,不能直接用URL。容易产生BackingBean中的相互依赖。</p><p>&nbsp;</p><p>4.用ActionListener侦听某个Action执行后，再来解析Request参数或jsf部件值，来加载数据。</p><img src="http://m1.img.srcdd.com/farm2/172/5DBF139516741BF9B4353638F7A5C6AC_1_1.GIF" /></body></html>
